require('dotenv').config();
const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const question = (prompt) => {
  return new Promise((resolve) => {
    rl.question(prompt, resolve);
  });
};

class SecuritySetup {
  constructor() {
    this.envPath = path.join(__dirname, '../.env');
    this.securityConfig = {};
  }

  generateSecureKey(length = 64) {
    return crypto.randomBytes(length).toString('hex');
  }

  generatePassword(length = 16) {
    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    let password = '';
    for (let i = 0; i < length; i++) {
      password += charset.charAt(Math.floor(Math.random() * charset.length));
    }
    return password;
  }

  async checkExistingEnv() {
    try {
      const envContent = await fs.readFile(this.envPath, 'utf8');
      return envContent;
    } catch (error) {
      return null;
    }
  }

  async promptForConfig() {
    console.log('üîí CrackZone Security Setup');
    console.log('=' .repeat(40));
    
    // JWT Secrets
    console.log('\nüìù JWT Configuration:');
    const useGeneratedJWT = await question('Generate secure JWT secrets automatically? (y/n): ');
    
    if (useGeneratedJWT.toLowerCase() === 'y') {
      this.securityConfig.JWT_SECRET = this.generateSecureKey(64);
      this.securityConfig.JWT_REFRESH_SECRET = this.generateSecureKey(64);
      console.log('‚úÖ JWT secrets generated');
    } else {
      this.securityConfig.JWT_SECRET = await question('Enter JWT secret (min 64 chars): ');
      this.securityConfig.JWT_REFRESH_SECRET = await question('Enter JWT refresh secret (min 64 chars): ');
    }

    // Session Secret
    console.log('\nüîê Session Configuration:');
    const useGeneratedSession = await question('Generate secure session secret automatically? (y/n): ');
    
    if (useGeneratedSession.toLowerCase() === 'y') {
      this.securityConfig.SESSION_SECRET = this.generateSecureKey(32);
      console.log('‚úÖ Session secret generated');
    } else {
      this.securityConfig.SESSION_SECRET = await question('Enter session secret (min 32 chars): ');
    }

    // Database Encryption
    console.log('\nüóÑÔ∏è  Database Encryption:');
    const useDbEncryption = await question('Enable database encryption? (y/n): ');
    
    if (useDbEncryption.toLowerCase() === 'y') {
      this.securityConfig.DB_ENCRYPTION_KEY = this.generateSecureKey(32);
      console.log('‚úÖ Database encryption key generated');
    }

    // Admin Credentials
    console.log('\nüë§ Admin Configuration:');
    this.securityConfig.ADMIN_USERNAME = await question('Enter admin username (default: admin): ') || 'admin';
    
    const useGeneratedAdminPassword = await question('Generate secure admin password automatically? (y/n): ');
    if (useGeneratedAdminPassword.toLowerCase() === 'y') {
      this.securityConfig.ADMIN_PASSWORD = this.generatePassword(20);
      console.log('‚úÖ Admin password generated');
      console.log(`üîë Admin Password: ${this.securityConfig.ADMIN_PASSWORD}`);
      console.log('‚ö†Ô∏è  IMPORTANT: Save this password securely!');
    } else {
      this.securityConfig.ADMIN_PASSWORD = await question('Enter admin password: ');
    }

    // CORS Configuration
    console.log('\nüåê CORS Configuration:');
    const corsOrigin = await question('Enter allowed origins (comma-separated, default: http://localhost:5174): ');
    this.securityConfig.CORS_ORIGIN = corsOrigin || 'http://localhost:5174';

    // Rate Limiting
    console.log('\n‚è±Ô∏è  Rate Limiting:');
    const useDefaultRates = await question('Use default rate limits? (y/n): ');
    
    if (useDefaultRates.toLowerCase() !== 'y') {
      this.securityConfig.RATE_LIMIT_MAX_REQUESTS = await question('Max requests per 15 min (default: 1000): ') || '1000';
      this.securityConfig.RATE_LIMIT_AUTH_MAX = await question('Max auth attempts per 15 min (default: 10): ') || '10';
    }

    // Security Monitoring
    console.log('\nüìä Security Monitoring:');
    const enableWebhook = await question('Enable webhook alerts? (y/n): ');
    if (enableWebhook.toLowerCase() === 'y') {
      this.securityConfig.SECURITY_WEBHOOK_URL = await question('Enter webhook URL: ');
    }

    const emailAlerts = await question('Enter email for security alerts (optional): ');
    if (emailAlerts) {
      this.securityConfig.SECURITY_EMAIL_ALERTS = emailAlerts;
    }
  }

  async updateEnvFile() {
    let envContent = await this.checkExistingEnv() || '';
    
    // Add security configuration
    const securitySection = '\n# Security Configuration (Generated by setup-security.js)\n';
    let newSecurityConfig = securitySection;
    
    for (const [key, value] of Object.entries(this.securityConfig)) {
      // Check if key already exists
      const regex = new RegExp(`^${key}=.*$`, 'm');
      if (regex.test(envContent)) {
        // Update existing
        envContent = envContent.replace(regex, `${key}=${value}`);
      } else {
        // Add new
        newSecurityConfig += `${key}=${value}\n`;
      }
    }

    // Add new config if not already in file
    if (!envContent.includes('# Security Configuration')) {
      envContent += newSecurityConfig;
    }

    await fs.writeFile(this.envPath, envContent);
    console.log(`‚úÖ Security configuration saved to ${this.envPath}`);
  }

  async runSecurityMigration() {
    console.log('\nüóÑÔ∏è  Running security database migration...');
    try {
      const { createSecurityTables } = require('./migrate-security-tables');
      await createSecurityTables();
      console.log('‚úÖ Security tables created successfully');
    } catch (error) {
      console.error('‚ùå Migration failed:', error.message);
      console.log('üí° You can run the migration manually: node scripts/migrate-security-tables.js');
    }
  }

  async validateConfiguration() {
    console.log('\nüîç Validating security configuration...');
    
    const warnings = [];
    const errors = [];

    // Check JWT secret length
    if (this.securityConfig.JWT_SECRET && this.securityConfig.JWT_SECRET.length < 64) {
      warnings.push('JWT secret should be at least 64 characters long');
    }

    // Check admin password strength
    if (this.securityConfig.ADMIN_PASSWORD) {
      const password = this.securityConfig.ADMIN_PASSWORD;
      if (password.length < 12) {
        warnings.push('Admin password should be at least 12 characters long');
      }
      if (!/[A-Z]/.test(password)) {
        warnings.push('Admin password should contain uppercase letters');
      }
      if (!/[a-z]/.test(password)) {
        warnings.push('Admin password should contain lowercase letters');
      }
      if (!/[0-9]/.test(password)) {
        warnings.push('Admin password should contain numbers');
      }
      if (!/[!@#$%^&*]/.test(password)) {
        warnings.push('Admin password should contain special characters');
      }
    }

    if (warnings.length > 0) {
      console.log('‚ö†Ô∏è  Warnings:');
      warnings.forEach(warning => console.log(`  - ${warning}`));
    }

    if (errors.length > 0) {
      console.log('‚ùå Errors:');
      errors.forEach(error => console.log(`  - ${error}`));
      return false;
    }

    console.log('‚úÖ Configuration validation passed');
    return true;
  }

  async showSummary() {
    console.log('\n' + '='.repeat(50));
    console.log('üéâ Security Setup Complete!');
    console.log('='.repeat(50));
    
    console.log('\nüìã Configuration Summary:');
    console.log(`‚úÖ JWT secrets: ${this.securityConfig.JWT_SECRET ? 'Generated' : 'Not set'}`);
    console.log(`‚úÖ Session secret: ${this.securityConfig.SESSION_SECRET ? 'Generated' : 'Not set'}`);
    console.log(`‚úÖ Database encryption: ${this.securityConfig.DB_ENCRYPTION_KEY ? 'Enabled' : 'Disabled'}`);
    console.log(`‚úÖ Admin account: ${this.securityConfig.ADMIN_USERNAME || 'admin'}`);
    console.log(`‚úÖ CORS origins: ${this.securityConfig.CORS_ORIGIN || 'Default'}`);
    console.log(`‚úÖ Security monitoring: ${this.securityConfig.SECURITY_WEBHOOK_URL ? 'Enabled' : 'Basic'}`);

    console.log('\nüöÄ Next Steps:');
    console.log('1. Start your server: npm run dev');
    console.log('2. Test security: node scripts/test-security.js');
    console.log('3. Review security documentation: SECURITY_IMPLEMENTATION.md');
    console.log('4. Configure production SSL certificates');
    console.log('5. Set up monitoring and alerting');

    if (this.securityConfig.ADMIN_PASSWORD) {
      console.log('\nüîë IMPORTANT - Save these credentials:');
      console.log(`Admin Username: ${this.securityConfig.ADMIN_USERNAME}`);
      console.log(`Admin Password: ${this.securityConfig.ADMIN_PASSWORD}`);
      console.log('‚ö†Ô∏è  Store these credentials securely!');
    }
  }

  async run() {
    try {
      await this.promptForConfig();
      await this.updateEnvFile();
      
      const isValid = await this.validateConfiguration();
      if (!isValid) {
        console.log('‚ùå Configuration validation failed. Please review and run setup again.');
        return;
      }

      await this.runSecurityMigration();
      await this.showSummary();
      
    } catch (error) {
      console.error('‚ùå Setup failed:', error.message);
    } finally {
      rl.close();
    }
  }
}

// Run setup if called directly
if (require.main === module) {
  const setup = new SecuritySetup();
  setup.run();
}

module.exports = SecuritySetup;